\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{array}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{color}
\usepackage{listings}
%\usepackage{arydshln}
%\usepackage{slashbox}
\usepackage{subfigure}
%\usepackage{cancel}
%\usepackage[bookmarks = false]{hyperref}
\usepackage[left=2cm, right=2cm, top=2cm, bottom=2cm]{geometry}

% Initialisation de listings
%\definecolor{mymauve}{rgb}{0.63,0.13,0.94}
%\definecolor{mygreen}{rgb}{0.13,0.55,0.13}
%\definecolor{mybeige}{rgb}{0.99,0.99,0.86}
%\definecolor{mygris}{rgb}{0.8,0.8,0.8}
\definecolor{light-gray}{gray}{0.50}
\lstset{
    columns=flexible,
	%numbers = left,				% placement de la numérotation des lignes
	numberstyle = \small,        	% taille du numéro de ligne
	stepnumber = 1,              	% ???
	numbersep = 10pt,            	% taille de l'espace de séparation entre numéro de ligne et code
	showspaces = false,          	% montrer les espaces
	showstringspaces=false,         % enlever les espaces str
	showtabs = false,            	% montrer les tabulations
	tab = rightarrowfill,        	% ???
	tabsize=3,						% tabulation size
	language = Java,             	% langage utilisé
	basicstyle = \footnotesize\tt,	% ???
	captionpos = b,					% ???
	linewidth=\linewidth,			% largeur de la fenetre de code
	breaklines = true,				% ???
	commentstyle = \color{light-gray}, % définition de la couleur des commentaires
	%stringstyle = \color{mymauve},  % définition de la couleur des chaines de caractères
	%identifierstyle = \ttfamily,    % ???
	keywordstyle = \color{blue},	% définition de la couleur des mots clés
	%frame=single,
	%backgroundcolor=\color{mybeige},
	extendedchars=true				% étend les caractères pouvant être utilisés
}

%\author{Mormont Romain}
%\title{Synthèse : Base de données (Pierre Wolper)}
%\date{Année académique 2013-2014}

\begin{document}
\rule{1\linewidth}{1px}
{ \sc
\begin{center}
{\small Université de Liège}\\
{\small Faculté des Sciences Appliquées}

\end{center}

\vfill
\begin{center}

{\Huge Introduction to computer networking {\LARGE \tt [INFO0010-1]}\\}
\end{center}
\begin{center}
{\Huge Projet 2 : Rapport}
\end{center}
\begin{center}
Mormont Romain, Servais Fabrice\\
{\small 3$^{\text{ème}}$  bachelier ingénieur civil, orientation ingénieur civil}\\
{\small Options \textit{informatique} et \textit{électricité et électronique}}\\
{\small s110940, s111093}
\end{center}

\vfill
\begin{center}
Année académique 2013-2014\\
\end{center}
}
\rule{1\linewidth}{1px}
\newpage

\section{Software architecture}
Le problème a été divisé en différents sous-problèmes que nous allons expliciter dans leur ordre temporel.

	\subsection{Vue globale de la solution}

	\subsubsection{Initialisation du Gateway}
Une instance de \texttt{Server} est créée au lancement de cette classe. Celle-ci crée une instance de \texttt{HTTPServer} et \texttt{ConfigurationServer} afin d'accepter les connexions entrantes vers le Gateway et la plate-forme de configuration. Elle récupère aussi le singleton \texttt{Displayer} servant à afficher des messages dans la console. Nous ne détaillerons pas la plate-forme de configuration.

	\subsubsection{Récupération des connexions entrantes}
La classe \texttt{HTTPServer} récupère les connexions entrantes et lance un thread (si possible par la thread-pool) pour chacune d'entre-elles par l'intermédiaire de la classe \texttt{HTTPClientRequestThread} et ce, après l'acceptation de connexion du socket.

	\subsubsection{Gestion des requêtes}
La classe \texttt{HTTPClientRequestThread} instancie un objet \texttt{HTTPRequest} en prenant le socket en argument. Celui-ci va récupérer la requête du navigateur et la parser pour en récupérer les différentes informations, notamment la méthode et le chemin.

\paragraph{}

On récupère alors l'adresse IP du Gateway qui va être utile lors du remplacement des liens, et l'on donne la requête récupérée à un nouvel objet de classe \texttt{GatewayRequestDecoder} qui va se charger de décoder la requête, c'est-à-dire récupérer l'adresse du site auquel l'utilisateur souhaite accéder et les éventuels paramètres (\texttt{forceRefresh}). On vérifie ensuite si l'adresse est correcte et que le format du fichier auquel on veut accéder est géré.

\paragraph{}

Pour le chemin donné, on regarde si la page est déjà contenue dans le cache et si celle-ci doit être rafraîchie dû au timeout ou à l'éventuel argument \texttt{forceRefresh}. Selon les cas, on va rechercher la page dans le cache ou sur le serveur distant. Dans ce cas-là, la méthode \texttt{getPageFromRemote(URL)} établit la connexion avec le serveur avec la classe \texttt{HttpURLConnection} et récupère le contenu de la page. Les liens de la page sont alors filtrés afin de les rediriger vers le Gateway. Les balises \texttt{img}, \texttt{link}, \texttt{frame} et \texttt{script} sont aussi filtrées afin de bypasser le Gateway. 

\paragraph{}

On clone ensuite la page récupérée (afin de ne pas altérer la page originale contenue dans le cache) puis on filtre la page en fonction des mots-clés interdits. Cette étape est réalisée après la récupération de la page du cache ou du serveur distant. En effet, il est possible que la page ait été modifiée sur le serveur distant pendant le temps où celle-ci se trouvait dans le cache, amenant possiblement des mots-clés interdits et devant provoquer une censure, ce qui n'aurait alors pas été le cas, jusqu'au timeout dans le cache. Si la page doit être censurée, on renvoie une page informant d'utilisateur qu'il ne peut pas accéder à la page. Sinon, on envoie une réponse HTTP contenant la page voulue ou pas selon si on répond à une requête GET ou HEAD.



	\subsection{Erreurs renvoyées par le Gateway}
Voici une liste de différentes erreurs renvoyées par le Gateway ainsi que l'action qui les a déclenchées : 
\begin{itemize}
	\setlength{\itemsep}{5pt}
	\item \textbf{Erreur 400 - Bad Request} : La requête du client n'a pu être lue (dû à la variable \texttt{s} manquante dans l'URL, argument de \texttt{s} vide,...)
	\item \textbf{Erreur 501 - Not Implemented} : Lorsque la requête que l'on reçoit n'est ni GET ni HEAD ou lorsque le format de la page demandée n'est pas prise en charge.
	\item 

\end{itemize}

\section{Multi-thread coordination}
L'accès au cache est \textit{thread-safe}. En effet, le cache est implémenté avec la classe \texttt{ConcurrentHashMap} qui est \textit{thread-safe}. De plus, nous avons ajouté l'attribut \texttt{synchronized} aux méthodes de \texttt{Cache} agissant avec le cache. Si deux threads tentent d'accéder à une même page se trouvant dans le cache, ces deux threads recevront la même page, sans incohérence.
\paragraph{}
Le seul moment où le cache est modifié est lors l'insertion ou la mise à jour d'une page lorsqu'un utilisateur demande cette page. Supposons que deux utilisateurs souhaitent accéder à la même page ne se trouvant pas dans le cache. Les deux threads demanderont tous les deux au serveur distant après la page, filtreront les liens et attributs cités au point 1.1.3, et tenteront de l'insérer dans le cache. Un premier y parviendra avant l'autre, et ce deuxième ajout aura pour effet d'écraser la précédente. Cependant, ceci n'est pas un problème puisque l'on peut supposer que la page n'a pas changé entre les moments où les utilisateurs ont demandé la page, celle-ci est alors dans le même état pour chacun des threads.
\paragraph{}
On peut noter aussi que le clonage de l'élément contenu dans le cache ajoute un niveau de sécurité supplémentaire car, lorsque l'on modifie la page, le cache n'est pas modifié, cela n'a donc pas d'incidence sur les autres threads.




\end{document}